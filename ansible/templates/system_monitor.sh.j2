# FILE: ansible/templates/system_monitor.sh.j2
#!/bin/bash
# System monitoring script for {{ app_name }}
# Generated by Ansible on {{ ansible_date_time.iso8601 }}

set -euo pipefail

# Configuration
APP_NAME="{{ app_name }}"
LOG_FILE="{{ log_directory }}/system.log"
METRICS_FILE="{{ log_directory }}/metrics.json"
AWS_REGION="{{ aws_region }}"
CLOUDWATCH_NAMESPACE="Custom/{{ app_name }}"

# Function to log with timestamp
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Function to collect system metrics
collect_metrics() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local epoch=$(date +%s)
    
    # CPU metrics
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | awk -F'%' '{print $1}')
    
    # Memory metrics
    local mem_total=$(free -m | awk 'NR==2{print $2}')
    local mem_used=$(free -m | awk 'NR==2{print $3}')
    local mem_free=$(free -m | awk 'NR==2{print $4}')
    local mem_percent=$(free | awk 'NR==2{printf "%.1f", $3*100/$2}')
    
    # Disk metrics
    local disk_total=$(df -h / | awk 'NR==2{print $2}')
    local disk_used=$(df -h / | awk 'NR==2{print $3}')
    local disk_free=$(df -h / | awk 'NR==2{print $4}')
    local disk_percent=$(df / | awk 'NR==2{print $5}' | sed 's/%//')
    
    # Load average
    local load_1min=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    local load_5min=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $2}' | sed 's/,//')
    local load_15min=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $3}')
    
    # Network metrics (if available)
    local rx_bytes=$(cat /proc/net/dev | grep eth0 | awk '{print $2}' || echo "0")
    local tx_bytes=$(cat /proc/net/dev | grep eth0 | awk '{print $10}' || echo "0")
    
    # Process metrics
    local app_processes=$(pgrep -f "$APP_NAME" | wc -l || echo "0")
    
    # Create JSON metrics
    cat > "$METRICS_FILE" << EOF
{
    "timestamp": "$timestamp",
    "epoch": $epoch,
    "hostname": "$(hostname)",
    "cpu": {
        "usage_percent": ${cpu_usage:-0}
    },
    "memory": {
        "total_mb": $mem_total,
        "used_mb": $mem_used,
        "free_mb": $mem_free,
        "usage_percent": $mem_percent
    },
    "disk": {
        "total": "$disk_total",
        "used": "$disk_used",
        "free": "$disk_free",
        "usage_percent": $disk_percent
    },
    "load_average": {
        "1min": $load_1min,
        "5min": $load_5min,
        "15min": $load_15min
    },
    "network": {
        "rx_bytes": $rx_bytes,
        "tx_bytes": $tx_bytes
    },
    "processes": {
        "app_count": $app_processes
    }
}
EOF

    # Send metrics to CloudWatch (if AWS CLI is available)
    if command -v aws >/dev/null 2>&1; then
        aws cloudwatch put-metric-data \
            --region "$AWS_REGION" \
            --namespace "$CLOUDWATCH_NAMESPACE" \
            --metric-data MetricName=CPUUtilization,Value=${cpu_usage:-0},Unit=Percent \
            --metric-data MetricName=MemoryUtilization,Value=$mem_percent,Unit=Percent \
            --metric-data MetricName=DiskUtilization,Value=$disk_percent,Unit=Percent \
            --metric-data MetricName=LoadAverage1Min,Value=$load_1min,Unit=Count \
            --metric-data MetricName=ApplicationProcesses,Value=$app_processes,Unit=Count \
            2>/dev/null || log_message "Warning: Failed to send metrics to CloudWatch"
    fi
    
    log_message "Metrics collected: CPU=${cpu_usage:-0}%, MEM=${mem_percent}%, DISK=${disk_percent}%, LOAD=${load_1min}, PROCS=${app_processes}"
}

# Main function
main() {
    collect_metrics
}

main "$@"